#   frame_foregnd    = Subtraced frame (frame - previous_frame)
#   frame_denoised      = Erosion of foreground frame
#   frame_xored         = Xor of frame_denoised
#   frame_at_depth      = Hand Depth Image
from pykinect2 import PyKinectV2
from pykinect2.PyKinectV2 import *
from pykinect2 import PyKinectRuntime
from matplotlib import pyplot as plt
from PIL import Image 
from skimage import data
from skimage.filters import threshold_otsu, threshold_adaptive
import scipy
import pickle

import ctypes
import _ctypes
import pygame
import sys
import numpy    
import cv2
 
mindepth = 500
maxdepth = 65535
mapdepthtobyte = 8000/256;
 
f = open("depth_image","w+")
 
class BodyGameRuntime(object):
    def __init__(self):
        pygame.init()
 
        # Set the width and height of the screen [width, height]
        self._infoObject = pygame.display.Info()
        self._screen = pygame.display.set_mode((self._infoObject.current_w >> 1, self._infoObject.current_h >> 1), pygame.HWSURFACE|pygame.DOUBLEBUF|pygame.RESIZABLE,  8)
 
        pygame.display.set_caption("Kinect for Windows v2 Body Game")
 
        # Loop until the user clicks the close button.
        self._done = False
 
        # Used to manage how fast the screen updates
        self._clock = pygame.time.Clock()
 
        # Kinect runtime object, we want only depth and body frames
        self._kinect = PyKinectRuntime.PyKinectRuntime(PyKinectV2.FrameSourceTypes_Depth)
 
        # back buffer surface for getting Kinect depth frames,16bit depth, width and height equal to the Kinect depth frame size
        self._frame_surface = pygame.Surface((self._kinect.depth_frame_desc.Width, self._kinect.depth_frame_desc.Height), 0,  8)
        # here we will store skeleton data
        self._bodies = None
 
 
    def draw_depth_frame(self, frame, target_surface):
        target_surface.lock()
        address = self._kinect.surface_as_array(target_surface.get_buffer())
        ctypes.memmove(address, frame.ctypes.data, frame.size)
        del address
        target_surface.unlock()
 
 
    def subtract_frames(self,frame,previous_frame):
        #frame_foregnd = numpy.absolute(numpy.subtract(previous_frame,frame))
        # print numpy.shape(frame_foregnd)
        frame_foregnd=cv2.subtract(frame,previous_frame)
        return frame_foregnd
 
    def get_hand(self,frame,frame_xored,max_hist):
        frame_at_depth=numpy.where((frame >=(max_hist-tolerance))&(frame <=(max_hist+tolerance)), frame, 0)
        frame_hand=frame_at_depth and frame_xored


    def max_hist_depth(self, frame):    
        #print 'FRAME_MAX = ' + str(frame.max())
        binaries = int(frame.max())
        if binaries <= 0:
            return 0
        histogram, bins = numpy.histogram(frame, bins = binaries)
        histogram = histogram.tolist(); bins = bins.tolist(); 
        histogram[0 : 1] = [0, 0]
        max_hist = bins[ histogram.index( max(histogram) ) ]
        return max_hist
 
    def run(self):
        previous_frame = None

        while not self._done:
            #Main event loop
            for event in pygame.event.get():        # User did something
                if event.type == pygame.QUIT:       # If user clicked close
                    self._done = True               # Flag that we are done so we exit this loop
 
                elif event.type == pygame.VIDEORESIZE: # Window Resized
                    self._screen = pygame.display.set_mode(event.dict['size'],
                                               pygame.HWSURFACE|pygame.DOUBLEBUF|pygame.RESIZABLE,  8)
                   
            # --- Game logic should go here
            # --- Getting frames and drawing  

            if self._kinect.has_new_depth_frame():
                raw_frame = self._kinect.get_last_depth_frame()
                
                frame = raw_frame

                frame = frame.reshape(424,512)
                #img = scipy.misc.toimage(frame)
                
                #frame <<= 8
                frame = frame.astype(numpy.uint8)

                if previous_frame != None:
                    frame_foregnd  = cv2.subtract(frame,previous_frame)
                    frame_foregnd.astype(numpy.uint8) 
                    # f=open('frame_foregnd','w')
                    # f.seek(0)
                    
                    #img1 = scipy.misc.toimage(frame)
                    #img2 = scipy.misc.toimage(previous_frame) 
                    #img3.save("denoised1.png")  

                    #frame_denoised = scipy.ndimage.morphology.binary_opening(frame_foregnd,iterations=3)     
                    #frame_denoised = scipy.ndimage.morphology.binary_dilation(frame_foregnd,iterations=3)
                    #frame_denoised = scipy.ndimage.morphology.binary_erosion(frame_foregnd,iterations=3)
                    #frame_denoised = scipy.ndimage.filters.median_filter(frame_foregnd,size=(10,10))
                    # img = scipy.misc.toimage(frame_foregnd)
                    # img.save("denoised.png")     
                    
                    frame_xored = numpy.where(frame_foregnd != 0, 65536, 0) 

                    for i in range(200,424):
                        for j in range(100,300):
                            frame_xored[i][j]=40000

                    #frame_xored.tofile(f,format="%s")


                    # # frame_xored = frame_xored.reshape(512,424)
                    
                    # hand_depth = self.max_hist_depth(frame_xored)
                    # #print hand_depth
                    # hand_filtered_frame = numpy.where(frame_xored > (hand_depth + 5),0 , frame_xored)
                    # hand_filtered_frame = numpy.where(hand_filtered_frame < (hand_depth - 5),0 , hand_filtered_frame)

                    # #print_frame = numpy.astype(img,dtype = numpy.uint8)
                    print_frame = frame_foregnd
                    print_frame >>= 8
                    print_frame = print_frame.astype(numpy.uint8)

                    cv2.imshow('frame_foregnd',frame_xored)


                    self.draw_depth_frame(print_frame, self._frame_surface)
                    print_frame.reshape(512,424)
                    
        
                previous_frame=frame
 
            #Copy back buffer surface pixels to the screen, resize it if needed and keep aspect ratio
            #(screen size may be different from Kinect's depth frame size)
            h_to_w = float(self._frame_surface.get_height()) / self._frame_surface.get_width()
            target_height = int(h_to_w * self._screen.get_width())
            surface_to_draw = pygame.transform.scale(self._frame_surface, (self._screen.get_width(), target_height));
            self._screen.blit(surface_to_draw, (0,0))
            surface_to_draw = None
            pygame.display.update()
 
            # --- Go ahead and update the screen with what we've drawn.
            pygame.display.flip()
 
            # --- Limit to 60 frames per second
            self._clock.tick(60)
 
        # Close our Kinect sensor, close the window and quit.
        self._kinect.close()
        pygame.quit()
 
 
__main__ = "Kinect v2 Body Game"
game = BodyGameRuntime();
game.run();